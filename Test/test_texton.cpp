#include <stdlib.h>

#include "ASTex/rpn_utils.h"
#include "ASTex/utils.h"
#include "ASTex/easy_io.h"

#include "ASTex/Stamping/stamper.h"
#include "ASTex/histogram.h"
#include "ASTex/Stamping/stamper.h"
#include "ASTex/histogram.h"
#include "ASTex/texton_io.h"

/**
 * @brief this is a template for making texton noise.
 * Change the variable MY_PATH to the patch you have your images.
 * You can safely change the following lines:
 * sampler.setNbPoints(300);
 *      ^ which specifies the number of times texton noise hits the output texture
 * stamp.setInterpolationRule(Stamping::StampDiscrete<ImageRGBd>::BILINEAR);
 *      ^ which specifies the interpolation rule (we shoot between pixels)
 * tamponneur.setPeriodicity(false);
 *      ^ which specifies whether the output image is allowed to be periodic or not
 * @return 0
 */
int main(int argc, char **argv)
{
	if( argc < 5 )
	{
		std::cerr << "Usage: " << std::endl;
		std::cerr << argv[0] << "<input image> <output filename> <output width> <output height>" << std::endl;

		return EXIT_FAILURE;
	}

	Eigen::Vector2f t0, t1; //cyclostationary period vectors
	t0 = Eigen::Vector2f(0.05, 0);
	t1 = Eigen::Vector2f(0, 0.05);

	std::string filename_source=argv[1];
	std::string name_file = IO::remove_path(filename_source);
	std::string name_noext = IO::remove_ext(name_file);

	std::string filename_output=argv[2];

	int width = std::atoi(argv[3]);
	int height = std::atoi(argv[4]);

	//Loading im_in

	ImageRGBd im_out, im_sample, im_texton;

	//these import functions turn a texton file into a vizualizable image
	if(!import_texton(im_texton, filename_source))
	{
		import_texton_from_png(im_texton, filename_source);
	}

	///STATIONARY VERSION
//	HistogramRGBd histo_texton(im_texton);
//	ImageRGBd::PixelType mean;
//	for(int i=0; i<3; ++i)
//		mean[i] = histo_texton.mean(i);
//	//transformation image -> texton
//	im_texton.for_all_pixels([&] (ImageRGBd::PixelType &pix) {
//		pix -= mean;
//		pix = pix * (1.0/std::sqrt(im_texton.width()*im_texton.height()));
//	});

	///CYCLOSTATIONARY VERSION
	///Because I could hardly find a better way to do it, the time-varying mean (1st order moment) is estimated.
	///I think it can be computed (beyond reasonable doubt) by computing the lattice generated by the periods,
	///and putting exactly one spot on each vertice of the grid. The result is THE first order moment.
	///
	///Another constraint: to work, the CADSN as implemented here must have fractions of 1 on each coordinate of each period.
	ImageRGBd meanImage;
	meanImage.initItk(width, height);
	Stamping::SamplerCycles samplerMean;
	samplerMean.setNbPoints(1);
	samplerMean.setCycles(t0, t1);
	Stamping::StampDiscrete<ImageRGBd> stampMean(im_texton); //without substracting the mean
	stampMean.setInterpolationRule(Stamping::StampDiscrete<ImageRGBd>::BILINEAR);
	Stamping::StamperTexton<ImageRGBd> stamperMean(&samplerMean, &stampMean);
	stamperMean.setPeriodicity(false);
	stamperMean.setUseMargins(true);
	ImageRGBd meanPool = stamperMean.generate(width, height);
	meanImage.for_all_pixels([&] (ImageRGBd::PixelType &pix, int x, int y)
	{
		unsigned maxCyclesX = unsigned(std::floor(1.0/t0.x()));
		unsigned maxCyclesY = unsigned(std::floor(1.0/t1.y()));
		for(unsigned cx=0; cx<maxCyclesX; ++cx)
		{
			for(unsigned cy=0; cy<maxCyclesY; ++cy)
			{
				int xShift= int(x	+ (cx*t0.x()
									+ cy*t1.x())*meanImage.width())%meanImage.width();
				int yShift= int(y	+ (cx*t0.y()
									+ cy*t1.y())*meanImage.height())%meanImage.height();
				pix += bilinear_interpolation(meanPool, xShift, yShift, true);
			}
		}
		pix = pix * (1.0/(maxCyclesX*maxCyclesY));
	});
	im_texton.for_all_pixels([&] (ImageRGBd::PixelType &pix, int x, int y)
	{
		pix = pix - 0.5;//meanImage.pixelAbsolute(x, y);
		pix = pix * (1.0/std::sqrt(im_texton.width()*im_texton.height()));
	});
	//IO::save01_in_u8(meanImage, TEMPO_PATH+"meanImage.png");

	//Testing

	Stamping::SamplerCycles sampler; //you can make it a PoissonGrid but it won't be as good
	sampler.setNbPoints(1600); //< more than 30 with a PoissonSampler, more than, maybe, 100 with a uniform sampler
	sampler.setCycles(t0, t1);
	Stamping::StampDiscrete<ImageRGBd> stamp(im_texton);
	stamp.setInterpolationRule(Stamping::StampDiscrete<ImageRGBd>::BILINEAR); //< you can change that too

	Stamping::StamperTexton<ImageRGBd> stamper(&sampler, &stamp);

	stamper.setPeriodicity(false);
	stamper.setUseMargins(true);

	im_out = stamper.generate(width, height);

	//transformation texton -> image
	///STATIONARY VERSION
//	im_out.for_all_pixels([&] (ImageRGBd::PixelType &pix) {
//		pix += mean;
//	});

	///CYCLOSTATIONARY VERSION
	im_out.for_all_pixels([&] (ImageRGBd::PixelType &pix, int x, int y)
	{
		pix = pix + 0.5;//meanImage.pixelAbsolute(x, y);
	});

	im_sample.initItk(width, height, true);


	std::vector<Eigen::Vector2f> pointArray = sampler.generate();
	for(std::vector<Eigen::Vector2f>::iterator it=pointArray.begin(); it!=pointArray.end(); ++it)
	{
		int i = int(im_sample.width() * (*it)[0]); //i & j: single point coordinates in im_out
		int j = int(im_sample.height() * (*it)[1]);

		im_sample.pixelAbsolute(i, j)=1.0;
	}

	//colored_RPN(im_in, im_rpn, RGB_SPACE, NORMAL, 0, 0, false, true, false, 1.0);

	auto clamp = [&] (ImageRGBd::PixelType &pix) { for(int i=0; i<3; ++i) pix[i] = pix[i] > 1.0 ? 1.0 : (pix[i] < 0.0 ? 0.0 : pix[i]); };
	im_out.for_all_pixels(clamp);

	//Saving sample
	//Saving im_out
	//IO::save01_in_u8(im_sample, some_output);
	IO::save01_in_u8(im_out, filename_output);
//	IO::save01_in_u8(im_texton, std::string(MY_PATH) + name_noext + "_texton.png");

	return 0;
}
