
//#include <cstdio>
#include <ctime>
#include <fstream>
#include <cmath>

#include <ASTex/easy_io.h>
#include <ASTex/special_io.h>
#include <ASTex/fourier.h>
#include <ASTex/utils.h>
#include <ASTex/colorspace_filters.h>
#include <ASTex/special_io.h>
#include <itkForwardFFTImageFilter.h>
#include <itkInverseFFTImageFilter.h>

#include <Eigen/Dense>
#include <iostream>


namespace  ASTex
{

inline int Factorial(int x) {
  if(x==0)
      return 1;
  else
  return (x == 1 ? x : x * Factorial(x - 1));
}

// Evaluate the B-spline function of order n on the points t
float spline_kernel(int t,int n){
float res = 0;

for(int k = 0; k<=(n+1); k++){
    res = res + (n+1)*std::pow(-1,k)/(Factorial(k)*Factorial(n+1-k))*std::pow((std::max(0.f,(n+1.f)/2.f+t-k)),n);
}
    return res;
}

//Import a texton from a file generated by the original mathlab implem
int import_texton(std::string file_path, ASTex::ImageRGBd& texton ){

    std::ifstream infile;
    infile.open(file_path, std::ifstream::in);

    std::cout <<" OPEN FILED "<< std::endl;

    // First line: Should be TEXTON
    std::string mystring;
    std::getline(infile,mystring);
    if(mystring.compare("TEXTON")!=0){
        std::cerr << "Not a Texton file" << std::endl;
        std::cout <<mystring<< std::endl;

        return EXIT_FAILURE;
    }
    // Second line: Version
    std::getline(infile,mystring);
    int version = atoi(mystring.c_str());
    if (version !=1 ){
        std::cerr << "Version number not supported: only supported versions are 1" << std::endl;
        return EXIT_FAILURE;
    }

    // 3rd line: order
    std::getline(infile,mystring);
    int order = atoi(mystring.c_str());
    // 4th line: mean
    std::getline(infile,mystring,' ');
    float mu_r = atof(mystring.c_str());
    std::getline(infile,mystring,' ');
    float mu_g = atof(mystring.c_str());
    std::getline(infile,mystring);
    float mu_b = atof(mystring.c_str());
    //mu = reshape(mu, [1,1,3]);
    // 5th line: size
    std::getline(infile,mystring,' ');
    int M = atoi(mystring.c_str());


    std::getline(infile,mystring);
    int N = atoi(mystring.c_str());

    std::cout <<" vesrsion "<<version<<  std::endl;
    std::cout <<" order "<<order<<  std::endl;
    std::cout <<" mu "<<mu_r<< " "<< mu_g <<" "<< mu_b << std::endl;
    std::cout <<" size "<<M << " " << N<<  std::endl;

    texton.initItk(M,N,true);

    for (int y = 0; y < N; ++y) {
        for (int x = 0; x < M; ++x) {
            std::getline(infile,mystring,' ');
            float val = atof(mystring.c_str());
            texton.pixelAbsolute(x+(256-M)/2,y+(256-N)/2)[0] = val;
            std::getline(infile,mystring,' ');
            float val2 = atof(mystring.c_str());
            texton.pixelAbsolute(x+(256-M)/2,y+(256-N)/2)[1] = val2;
            std::getline(infile,mystring);
            float val3 = atof(mystring.c_str());
            texton.pixelAbsolute(x+(256-M)/2,y+(256-N)/2)[2] = val3;
        }
    }

    std::getline(infile,mystring,'\n');
    std::cout <<" Texton loaded "<< mystring << " end" << std::endl;
    infile.close();

    return 0;
}

using namespace ASTex;
/**
 * @brief decomposition periodic + smooth
 * @param input input grayd image
 * @return a pair of image (periodic,smooth)
 */
std::pair<ImageGrayd,ImageGrayd> decompo(const ImageGrayd& input)
{
    int W = input.width();
    int H = input.height();

    // 1 - compute boundary intensity (v)
    ImageGrayd bound(W,H,true);
    for (int x=0;x<W;x++)
    {
        double v = input.pixelAbsolute(x,0) - input.pixelAbsolute(x,H-1);
        bound.pixelAbsolute(x,0) += v;
        bound.pixelAbsolute(x,H-1) -= v;
    }
    for (int y=0;y<H;y++)
    {
        double v = input.pixelAbsolute(0,y) - input.pixelAbsolute(W-1,y);
        bound.pixelAbsolute(0,y) += v;
        bound.pixelAbsolute(W-1,y) -= v;
    }

    // 2 - DFT of v
    using  FFTType = itk::ForwardFFTImageFilter< ImageGrayd::ItkImg, ImageSpectralcd::ItkImg >;
    FFTType::Pointer fftFilter = FFTType::New();
    fftFilter->SetInput(bound.itk());
    fftFilter->Update();
    ImageSpectralcd ft_bound(fftFilter->GetOutput());

    // 3 - divide by cosin....
    //
    // compute coef by row
    double cx = 2.0*M_PI/double(W);
    std::vector<double> coef_x(W);
    for (int x=0; x<W; ++x)
        coef_x[x] = 2*std::cos(cx*x);
    // by column
    double cy = 2.0*M_PI/double(H);
    std::vector<double> coef_y(H);
    for (int y=0; y<H; ++y)
        coef_y[y] = 2*std::cos(cy*y);
    // apply computations on all pixels
    ft_bound.for_all_pixels([&] (ImageSpectralcd::PixelType& P, int x, int y)
    {
        P /= 4 - coef_x[x] - coef_y[y]; // WARNING OPPOSITE SIGN COMPARE TO ARTICLE
    });
    // except for (0,0) -> 0,0
    ft_bound.pixelAbsolute(0,0) = ImageSpectralcd::PixelType(0,0);


    // 4 - FFT inverse => smooth
    //
    using  IFFTType = itk::InverseFFTImageFilter< ImageSpectralcd::ItkImg, ImageGrayd::ItkImg >;
    IFFTType::Pointer ifftFilter = IFFTType::New();
    ifftFilter->SetInput(ft_bound.itk());
    ifftFilter->Update();
    ImageGrayd smooth(ifftFilter->GetOutput());


    // 4' - compute periodic = input - smooth
    //
    ImageGrayd perio(W,H,true);
	for(auto its = std::make_tuple(perio.beginIterator(),input.beginConstIterator(),smooth.beginConstIterator());
         !std::get<0>(its).IsAtEnd(); ++std::get<0>(its), ++std::get<1>(its), ++std::get<2>(its))
    {
        std::get<0>(its).Value() = std::get<1>(its).Value() - std::get<2>(its).Value();
    }

    return std::make_pair(perio,smooth);
}

/**
 * @brief corrige les images ?
 * @param in input
 * @param per periodic (clamped to [0,1])
 * @param smo smooth (shifted +0.5 & clamped to [0,1])
 */
void corrige(const ImageGrayd& in, ImageGrayd& per, ImageGrayd& smo)
{
    double min0 = compute_min(in);
    double max0 = compute_max(in);
    std::cout << "input " << min0 << " / " << max0 << std::endl;
    double min1 = compute_min(per);
    double max1 = compute_max(per);
    std::cout << "perio " << min1 << " / " << max1 << std::endl;
    double min2 = compute_min(smo);
    double max2 = compute_max(smo);
    std::cout << "smooth " << min2 << " / " << max2<< std::endl;

    per.for_all_pixels([&] (double& p)
    {
        if (p>1.0)
            p=1.0;
        if (p<0.0)
            p=0.0;
    });

    smo.for_all_pixels([&] (double& p)
    {
        p += 0.5;
        if (p>1.0)
            p=1.0;
        if (p<0.0)
            p=0.0;
    });
}

ImageRGBd x4(const ImageRGBd& input)
{
    int W = input.width();
    int H = input.height();

    ImageRGBd quad(W*2,H*2);

    for_indices(0,W,0,H,[&] (int x, int y)
    {
        auto v = input.pixelAbsolute(x,y);
        quad.pixelAbsolute(x,y) = v;
        quad.pixelAbsolute(W+x,y) = v;
        quad.pixelAbsolute(x,H+y) = v;
        quad.pixelAbsolute(W+x,H+y) = v;
    });

    return quad;
}



//void analyse_texton(const ASTex::ImageRGBd& input_color, ASTex::ImageRGBd& image_alpha_visu, ASTex::ImageRGBd& image_alpha_visu_bounded)
void analyse_texton( const ASTex::ImageRGBd& input_color,
					 std::vector<ASTex::ImageRGBd>& images_alpha_visu,
					 std::vector<ASTex::ImageRGBd>& images_alpha_visu_bounded)
{
	images_alpha_visu.clear();
	images_alpha_visu_bounded.clear();

    // Size of all images
    int w_size = input_color.width();
    int h_size = input_color.height();

    // Split all input channels into scalar images, needed for the fft.
    ASTex::ImageGrayd input_R_chan;
    ASTex::ImageGrayd input_G_chan;
    ASTex::ImageGrayd input_B_chan;

    input_R_chan.initItk(w_size,h_size);
    input_G_chan.initItk(w_size,h_size);
    input_B_chan.initItk(w_size,h_size);

    for (int y = 0; y < h_size; ++y)
        for (int x = 0; x< w_size; ++x){
            input_R_chan.pixelAbsolute(x,y)=input_color.pixelAbsolute(x,y)[0];
            input_G_chan.pixelAbsolute(x,y)=input_color.pixelAbsolute(x,y)[1];
            input_B_chan.pixelAbsolute(x,y)=input_color.pixelAbsolute(x,y)[2];
        }

    //Split each channel into Smooth + Periodic using "Periodic plus smooth image decomposition , Lionel Moisan" and keep the periodic part as rectified input
    auto outs_R = decompo(input_R_chan);
    corrige(input_R_chan, outs_R.first, outs_R.second);
    auto outs_G = decompo(input_G_chan);
    corrige(input_G_chan, outs_G.first, outs_G.second);
    auto outs_B = decompo(input_B_chan);
    corrige(input_B_chan, outs_B.first, outs_B.second);

    ASTex::ImageRGBd input_periodic_test;
    input_periodic_test.initItk(w_size,h_size);

    for (int y = 0; y < h_size; ++y)
        for (int x = 0; x< w_size; ++x){
            input_periodic_test.pixelAbsolute(x,y)[0]= outs_R.first.pixelAbsolute(x,y);
            input_periodic_test.pixelAbsolute(x,y)[1]= outs_G.first.pixelAbsolute(x,y);
            input_periodic_test.pixelAbsolute(x,y)[2]= outs_B.first.pixelAbsolute(x,y);

            input_R_chan.pixelAbsolute(x,y)=outs_R.first.pixelAbsolute(x,y);
            input_G_chan.pixelAbsolute(x,y)=outs_G.first.pixelAbsolute(x,y);
            input_B_chan.pixelAbsolute(x,y)=outs_B.first.pixelAbsolute(x,y);
        }

    //Compute input mean for each chan
    float mean_r=0;
    float mean_g=0;
    float mean_b=0;
    int nb_pix = 0;

    for (int y = 0; y < h_size; ++y)
        for (int x = 0; x< w_size; ++x){
            mean_r += input_R_chan.pixelAbsolute(x,y);
            mean_g += input_G_chan.pixelAbsolute(x,y);
            mean_b += input_B_chan.pixelAbsolute(x,y);
            nb_pix++;
        }
    mean_r/=nb_pix;
    mean_g/=nb_pix;
    mean_b/=nb_pix;

    std::cout <<" Success: Mean computed. R  : "<< mean_r<< " G : " <<mean_g<<" B :"<<mean_b<<  std::endl;

    //Substract mean creating the T image
    ASTex::ImageGrayd image_t_R_chan;
    ASTex::ImageGrayd image_t_G_chan;
    ASTex::ImageGrayd image_t_B_chan;

    image_t_R_chan.initItk(w_size,h_size);
    image_t_G_chan.initItk(w_size,h_size);
    image_t_B_chan.initItk(w_size,h_size);

    for (int y = 0; y < h_size; ++y)
        for (int x = 0; x< w_size; ++x){
            image_t_R_chan.pixelAbsolute(x,y) = (1.f/std::sqrt(w_size*h_size))*(input_R_chan.pixelAbsolute(x,y)-mean_r);
            image_t_G_chan.pixelAbsolute(x,y) = (1.f/std::sqrt(w_size*h_size))*(input_G_chan.pixelAbsolute(x,y)-mean_g);
            image_t_B_chan.pixelAbsolute(x,y) = (1.f/std::sqrt(w_size*h_size))*(input_B_chan.pixelAbsolute(x,y)-mean_b);
        }

    std::cout <<" Success: Mean substract"<<  std::endl;

    // Compute t fft
    ASTex::ImageSpectrald FFT_t_modulus_R_chan;
    ASTex::ImageSpectrald FFT_t_modulus_G_chan;
    ASTex::ImageSpectrald FFT_t_modulus_B_chan;

    ASTex::ImageSpectrald FFT_t_phase_R_chan;
    ASTex::ImageSpectrald FFT_t_phase_G_chan;
    ASTex::ImageSpectrald FFT_t_phase_B_chan;

     ASTex::Fourier::fftForwardModulusAndPhase(image_t_R_chan,FFT_t_modulus_R_chan,FFT_t_phase_R_chan,false);
     ASTex::Fourier::fftForwardModulusAndPhase(image_t_G_chan,FFT_t_modulus_G_chan,FFT_t_phase_G_chan,false);
     ASTex::Fourier::fftForwardModulusAndPhase(image_t_B_chan,FFT_t_modulus_B_chan,FFT_t_phase_B_chan,false);

    std::cout <<" Success: FFT compute "<<  std::endl;

    //Check the article for more explaination on this params.
    int order = 1;
    int n = (2*order)+1;
    int indt1,indt2;

    //Create Bspline interpolation
    ASTex::ImageGrayd image_bspline;
    image_bspline.initItk(w_size,h_size,true);

    for (int t1 = -(n-1)/2; t1<= (n-1)/2 ;++t1){
        if (t1<0)
            indt1 = t1+w_size;
        else
            indt1 = t1;

          for (int t2 = -(n-1)/2; t2<= (n-1)/2 ;++t2){
            if(t2<0)
                indt2 = t2+h_size;
            else
                indt2 = t2;

            image_bspline.pixelAbsolute(indt1, indt2) = spline_kernel(t1,n)*spline_kernel(t2,n);
        }
    }

    //Compute Bspline FFT

    ASTex::ImageSpectrald FFT_b_modulus;
    ASTex::ImageSpectrald FFT_b_phase;
    ASTex::Fourier::fftForwardModulusAndPhase(image_bspline,FFT_b_modulus,FFT_b_phase,false);

    std::cout <<" Success: Bspline computed"<<  std::endl;

    std::srand(time(NULL));


    int pmax = ceil(log2(std::min(w_size,h_size)))-1;

	for(int pwoftwo = (pmax-2);pwoftwo<= pmax;pwoftwo++)
	{

        //Create alpha image init with white noise
        ASTex::ImageGrayd image_alpha_R_chan;
        ASTex::ImageGrayd image_alpha_G_chan;
        ASTex::ImageGrayd image_alpha_B_chan;

        image_alpha_R_chan.initItk(w_size,h_size);
        image_alpha_G_chan.initItk(w_size,h_size);
        image_alpha_B_chan.initItk(w_size,h_size);

        for (int y = 0; y < h_size; ++y)
            for (int x = 0; x< w_size; ++x){
                image_alpha_R_chan.pixelAbsolute(x,y) = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
                image_alpha_G_chan.pixelAbsolute(x,y) = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
                image_alpha_B_chan.pixelAbsolute(x,y) = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
            }

        std::cout <<" Success: Alpha init computed"<<  std::endl;

        //Create support mask :
        int mask_size = pow(2,pwoftwo);
        ASTex::ImageGrayd mask_support;
        mask_support.initItk(w_size,h_size,true);

        for (int y = 0; y < mask_size; ++y)
            for (int x = 0; x <mask_size; ++x){
                mask_support.pixelAbsolute(x,y) = 1;
            }

        std::cout <<" Success: Mask computed"<<  std::endl;

        //Impose power spectrum

        //TODO : User param nb loop ?
        for (int k = 0; k < 50; ++k) {

            ASTex::ImageSpectrald FFT_alpha_modulus_R_chan;
            ASTex::ImageSpectrald FFT_alpha_modulus_G_chan;
            ASTex::ImageSpectrald FFT_alpha_modulus_B_chan;

            ASTex::ImageSpectrald FFT_alpha_phase_R_chan;
            ASTex::ImageSpectrald FFT_alpha_phase_G_chan;
            ASTex::ImageSpectrald FFT_alpha_phase_B_chan;

            //Compute Alpha FFT for all channels
            ASTex::Fourier::fftForwardModulusAndPhase(image_alpha_R_chan,FFT_alpha_modulus_R_chan,FFT_alpha_phase_R_chan,false);
            ASTex::Fourier::fftForwardModulusAndPhase(image_alpha_G_chan,FFT_alpha_modulus_G_chan,FFT_alpha_phase_G_chan,false);
            ASTex::Fourier::fftForwardModulusAndPhase(image_alpha_B_chan,FFT_alpha_modulus_B_chan,FFT_alpha_phase_B_chan,false);

            for (int y = 0; y < h_size; ++y)
                for (int x = 0; x< w_size; ++x){
                    std::complex<double> sp_R_chan = std::polar(FFT_alpha_modulus_R_chan.pixelAbsolute(x,y),FFT_alpha_phase_R_chan.pixelAbsolute(x,y));
                    std::complex<double> sp_G_chan = std::polar(FFT_alpha_modulus_G_chan.pixelAbsolute(x,y),FFT_alpha_phase_G_chan.pixelAbsolute(x,y));
                    std::complex<double> sp_B_chan = std::polar(FFT_alpha_modulus_B_chan.pixelAbsolute(x,y),FFT_alpha_phase_B_chan.pixelAbsolute(x,y));

                    std::complex<double> spt_R_chan = std::polar(FFT_t_modulus_R_chan.pixelAbsolute(x,y),FFT_t_phase_R_chan.pixelAbsolute(x,y));
                    std::complex<double> spt_G_chan = std::polar(FFT_t_modulus_G_chan.pixelAbsolute(x,y),FFT_t_phase_G_chan.pixelAbsolute(x,y));
                    std::complex<double> spt_B_chan = std::polar(FFT_t_modulus_B_chan.pixelAbsolute(x,y),FFT_t_phase_B_chan.pixelAbsolute(x,y));


                    double delta_ph = std::arg(std::conj(spt_R_chan)*sp_R_chan+std::conj(spt_G_chan)*sp_G_chan+std::conj(spt_B_chan)*sp_B_chan) ;

                    FFT_alpha_phase_R_chan.pixelAbsolute(x,y) =FFT_t_phase_R_chan.pixelAbsolute(x,y)+ delta_ph;
                    FFT_alpha_phase_G_chan.pixelAbsolute(x,y) =FFT_t_phase_G_chan.pixelAbsolute(x,y)+ delta_ph;
                    FFT_alpha_phase_B_chan.pixelAbsolute(x,y) =FFT_t_phase_B_chan.pixelAbsolute(x,y)+ delta_ph;

                    FFT_alpha_modulus_R_chan.pixelAbsolute(x,y) = FFT_t_modulus_R_chan.pixelAbsolute(x,y)/std::sqrt(FFT_b_modulus.pixelAbsolute(x,y)) ;
                    FFT_alpha_modulus_G_chan.pixelAbsolute(x,y) = FFT_t_modulus_G_chan.pixelAbsolute(x,y)/std::sqrt(FFT_b_modulus.pixelAbsolute(x,y)) ;
                    FFT_alpha_modulus_B_chan.pixelAbsolute(x,y) = FFT_t_modulus_B_chan.pixelAbsolute(x,y)/std::sqrt(FFT_b_modulus.pixelAbsolute(x,y)) ;
                }

          ASTex::Fourier::fftInverseModulusAndPhase(FFT_alpha_modulus_R_chan,FFT_alpha_phase_R_chan,image_alpha_R_chan,false);
          ASTex::Fourier::fftInverseModulusAndPhase(FFT_alpha_modulus_G_chan,FFT_alpha_phase_G_chan,image_alpha_G_chan,false);
          ASTex::Fourier::fftInverseModulusAndPhase(FFT_alpha_modulus_B_chan,FFT_alpha_phase_B_chan,image_alpha_B_chan,false);

          // Apply support
          for (int y = 0; y < h_size; ++y)
              for (int x = 0; x< w_size; ++x){
                   if(mask_support.pixelAbsolute(x,y)!=1){
                       image_alpha_R_chan.pixelAbsolute(x,y)=0;
                       image_alpha_G_chan.pixelAbsolute(x,y)=0;
                       image_alpha_B_chan.pixelAbsolute(x,y)=0;
                   }
              }

        }
        std::cout <<" Success: Impose spectrum"<<  std::endl;

        //Texton with no pad ( visualisation purpose )
        ASTex::ImageGrayd image_alpha_nopading_R_chan;
        ASTex::ImageGrayd image_alpha_nopading_G_chan;
        ASTex::ImageGrayd image_alpha_nopading_B_chan;

        image_alpha_nopading_R_chan.initItk(mask_size,mask_size);
        image_alpha_nopading_G_chan.initItk(mask_size,mask_size);
        image_alpha_nopading_B_chan.initItk(mask_size,mask_size);

        for (int y = 0; y < mask_size; ++y){
            for (int x = 0; x <mask_size; ++x){
                image_alpha_nopading_R_chan.pixelAbsolute(x,y) = image_alpha_R_chan.pixelAbsolute(x,y);
                image_alpha_nopading_G_chan.pixelAbsolute(x,y) = image_alpha_G_chan.pixelAbsolute(x,y);
                image_alpha_nopading_B_chan.pixelAbsolute(x,y) = image_alpha_B_chan.pixelAbsolute(x,y);
            }
        }

        // Color correction //TODO : Extract correction covariance function
        Eigen::Matrix3d cov_input;
          cov_input<< 0,0,0,0,0,0,0,0,0;

          for (int y = 0; y < h_size; ++y)
              for (int x = 0; x< w_size; ++x){
                 Eigen::Vector3d color(input_R_chan.pixelAbsolute(x,y)-mean_r, input_G_chan.pixelAbsolute(x,y)-mean_g,input_B_chan.pixelAbsolute(x,y)-mean_b);

                 cov_input += color*color.transpose();
              }
        cov_input/=h_size*w_size;
        Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> es(cov_input);

        Eigen::Matrix3d cov_texton;
        cov_texton<< 0,0,0,0,0,0,0,0,0;
        for (int y = 0; y < h_size; ++y){
            for (int x = 0; x< w_size; ++x){
                for (int ty = -2*order; ty <= 2*order; ++ty){
                    for (int tx = -2*order; tx<= 2*order; ++tx){
                        const unsigned int px = (x+tx+w_size)%w_size;
                        const unsigned int py = (y+ty+h_size)%h_size;

                       Eigen::Vector3d color_shift(image_alpha_R_chan.pixelAbsolute(px,py), image_alpha_G_chan.pixelAbsolute(px,py),image_alpha_B_chan.pixelAbsolute(px,py));
                       Eigen::Vector3d color(image_alpha_R_chan.pixelAbsolute(x,y), image_alpha_G_chan.pixelAbsolute(x,y),image_alpha_B_chan.pixelAbsolute(x,y));

                         cov_texton += spline_kernel(tx,2*order+1)*spline_kernel(ty,2*order+1)*color*color_shift.transpose();
                     }
               }
            }
        }

        Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> es_tex(cov_texton);
        Eigen::Matrix3d sqrt_cov_ratio(es.operatorSqrt()*es_tex.operatorInverseSqrt());

        for (int y = 0; y < mask_size; ++y)
            for (int x = 0; x< mask_size; ++x){
                Eigen::Vector3d color(image_alpha_R_chan.pixelAbsolute(x,y), image_alpha_G_chan.pixelAbsolute(x,y),image_alpha_B_chan.pixelAbsolute(x,y));
                Eigen::Vector3d color_res(sqrt_cov_ratio*color);

                image_alpha_nopading_R_chan.pixelAbsolute(x,y)= color_res(0);
                image_alpha_nopading_G_chan.pixelAbsolute(x,y)= color_res(1);
                image_alpha_nopading_B_chan.pixelAbsolute(x,y)= color_res(2);

                image_alpha_R_chan.pixelAbsolute(x,y)= color_res(0);
                image_alpha_G_chan.pixelAbsolute(x,y)= color_res(1);
                image_alpha_B_chan.pixelAbsolute(x,y)= color_res(2);

            }

        std::cout <<" Success: Color correction"<<  std::endl;


    //WARNING, in the official mathlab code provided by the authors, a 0 padding ( one pixel border of the image ) is done.
    // it's not mentioned in the paper so we took the decision to not set it , if you want it uncomment the following lines

    //    for (int y = 0; y < mask_size; ++y)
    //        for (int x = 0; x< mask_size; ++x)
    //        {
    //        if (x==0 || y==0 || x==(mask_size - 1) || y==(mask_size - 1))
    //        {
    //            image_alpha_nopading_R_chan.pixelAbsolute(x,y) = 0;
    //            image_alpha_nopading_G_chan.pixelAbsolute(x,y) = 0;
    //            image_alpha_nopading_B_chan.pixelAbsolute(x,y) = 0;
    //        }
    //    }

        //Printing
		ASTex::ImageRGBd image_alpha_visu;
		image_alpha_visu.initItk(mask_size,mask_size);
		ASTex::ImageRGBd image_alpha_visu_bounded;
		image_alpha_visu_bounded.initItk(w_size,h_size,true);

        for (int y = 0; y < mask_size; ++y)
            for (int x = 0; x< mask_size; ++x){
               image_alpha_visu.pixelAbsolute(x,y)[0] = image_alpha_nopading_R_chan.pixelAbsolute(x,y);
               image_alpha_visu.pixelAbsolute(x,y)[1] = image_alpha_nopading_G_chan.pixelAbsolute(x,y);
               image_alpha_visu.pixelAbsolute(x,y)[2] = image_alpha_nopading_B_chan.pixelAbsolute(x,y);
            }
        for (int y = 0; y < h_size; ++y)
            for (int x = 0; x< w_size; ++x){
                image_alpha_visu_bounded.pixelAbsolute(x,y)[0] = image_alpha_R_chan.pixelAbsolute(x,y);
                image_alpha_visu_bounded.pixelAbsolute(x,y)[1] = image_alpha_G_chan.pixelAbsolute(x,y);
                image_alpha_visu_bounded.pixelAbsolute(x,y)[2] = image_alpha_B_chan.pixelAbsolute(x,y);
            }
        for (int y = 0; y < mask_size; ++y)
            for (int x = 0; x< mask_size; ++x){
               image_alpha_visu.pixelAbsolute(x,y)[0]*=std::sqrt((mask_size-2*order)*(mask_size-2*order));
               image_alpha_visu.pixelAbsolute(x,y)[1]*=std::sqrt((mask_size-2*order)*(mask_size-2*order));
               image_alpha_visu.pixelAbsolute(x,y)[2]*=std::sqrt((mask_size-2*order)*(mask_size-2*order));

               image_alpha_visu.pixelAbsolute(x,y)[0]+=mean_r;
               image_alpha_visu.pixelAbsolute(x,y)[1]+=mean_g;
               image_alpha_visu.pixelAbsolute(x,y)[2]+=mean_b;
            }
        for (int y = 0; y < h_size; ++y)
            for (int x = 0; x< w_size; ++x){
               image_alpha_visu_bounded.pixelAbsolute(x,y)[0]*=std::sqrt((mask_size-2*order)*(mask_size-2*order));
               image_alpha_visu_bounded.pixelAbsolute(x,y)[1]*=std::sqrt((mask_size-2*order)*(mask_size-2*order));
               image_alpha_visu_bounded.pixelAbsolute(x,y)[2]*=std::sqrt((mask_size-2*order)*(mask_size-2*order));

               image_alpha_visu_bounded.pixelAbsolute(x,y)[0]+=mean_r;
               image_alpha_visu_bounded.pixelAbsolute(x,y)[1]+=mean_g;
               image_alpha_visu_bounded.pixelAbsolute(x,y)[2]+=mean_b;
            }
        for (int y = 0; y < mask_size; ++y)
            for (int x = 0; x< mask_size; ++x){
               image_alpha_visu.pixelAbsolute(x,y)[0] = ASTex::clamp_scalar<double,double>(image_alpha_visu.pixelAbsolute(x,y)[0],0,1);
               image_alpha_visu.pixelAbsolute(x,y)[1] = ASTex::clamp_scalar<double,double>(image_alpha_visu.pixelAbsolute(x,y)[1],0,1);
               image_alpha_visu.pixelAbsolute(x,y)[2] = ASTex::clamp_scalar<double,double>(image_alpha_visu.pixelAbsolute(x,y)[2],0,1);
            }
        for (int y = 0; y < h_size; ++y)
            for (int x = 0; x< w_size; ++x){
               image_alpha_visu_bounded.pixelAbsolute(x,y)[0] = ASTex::clamp_scalar<double,double>(image_alpha_visu_bounded.pixelAbsolute(x,y)[0],0,1);
               image_alpha_visu_bounded.pixelAbsolute(x,y)[1] = ASTex::clamp_scalar<double,double>(image_alpha_visu_bounded.pixelAbsolute(x,y)[1],0,1);
               image_alpha_visu_bounded.pixelAbsolute(x,y)[2] = ASTex::clamp_scalar<double,double>(image_alpha_visu_bounded.pixelAbsolute(x,y)[2],0,1);
            }

		images_alpha_visu.push_back(image_alpha_visu);
		images_alpha_visu_bounded.push_back(image_alpha_visu_bounded);
     }
}

}

